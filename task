#!/usr/bin/env perl

use Modern::Perl;
use FindBin;
use Pod::Usage;
use Date::Parse;
use Time::Seconds;
use POSIX qw/strftime/;

use constant COMMANDS    => [ qw/man help start stop pause break reset list flush time/ ];
use constant CONFIG_KEYS => qw/LOG_DIRECTORY LOG_FILE SHORT/;
use constant CONFIG_LINE => qr/^\s*(.*?)\s*=\s*(.*?)\s*$/;
use constant LOG_LINE    => qr/^(\w+ \w+  ?\d+ \d+:\d+:\d+ \d+) (\w+)(?: (.+))?$/;

=head1 NAME

  task - Simple task timer

=head1 SYNOPSIS

  task start bug fix           # start a timer
  task start another bug fix   # stop the first and start a new one
  task stop                    # stop the second timer
  task start a third bug fix   # start a third
  task sub part 1              # start a subtimer without stopping the running timer
  task stop                    # stop the sub timer
  task stop                    # stop the third timer

=head1 COMMANDS

=head2 OVERVIEW

The general syntax is

  task [command] [args...]

where command is one of

  start  - start a timer
  stop   - stop the current timer
  pause  - pause all timers (use start with no args to resume)

  reset  - reset a timer
  list   - list all timers
  flush  - archive timers and start over
  time   - list current timer or specified timer

Specific help for commands are available via

  task help [command]

The full man page is available via

  task man

=cut

{
    no strict 'refs';
    my $command = shift @ARGV;
    $command ~~ COMMANDS ? $command->(@ARGV) : pod2usage( -verbose => 1 );
}

# fetch the configuration
sub config {
    state $config;
    return $config if $config;

    # defaults
    $config = {
        LOG_DIRECTORY    => "$FindBin::Bin/log/",
        LOG_FILE         => "current",
        DEFAULT_TASK     => "task",
    };

    # update via config files and environment
    update_config($config, read_config($_)) for ("/etc/task-timer", "$ENV{HOME}/.task-timer", "./.task-timer");
    update_config($config, %ENV);
    return $config;
}

# read config values from the passed file
# right now we just ignore invalid lines
sub read_config {
    my ($file) = @_;
    return unless -e $file;
    open my $fh, "<", $file or die "Failed to open configuration file $file: $!";   
    return map { $_ =~ CONFIG_LINE  } <$fh>;
}

# update the config hash
sub update_config {
    my ($config, %values) = @_;
    map { $config->{$_} = $values{$_} if defined $values{$_} } CONFIG_KEYS;
}

# read the current log
sub tasks {
    my $file = config->{LOG_DIRECTORY} . config->{LOG_FILE};
    open my $log, "<", $file or return {};

    my $tasks   = {};
    my $running = [];

    my $stop = sub {
        my ($time) = @_;
        my $task = pop @$running or return;
        $task->{time} += $time - $task->{start};
        delete $task->{start};
        return $task;
    };

    my $start = sub {
        my ($task, $time) = @_;
        $task->{start} = $time;
        push @$running, $task;
    };

    my $new = sub { { label => shift, time => 0, subtasks => {} } };

    while (<$log>) {
        my ($time, $command, $label) = $_ =~ LOG_LINE or die "Failed to parse $_ [$.]"; 
        my $epoch = str2time $time;
        given ($command) {
            when ("start") {
                &$stop($epoch) while @$running;
                &$start($tasks->{$label} ||= &$new($label), $epoch);
            }
            when ("sub") {
                my $task = $running->[-1] or die "No task running to create a sub task for";
                &$start($task->{subtasks}{$label} ||= &$new($label), $epoch);
            }
            when ("stop") {
                &$stop($epoch);
            }
            when ("reset") {
                $running = [] if @$running && $running->[0]{label} eq $label;
                delete $tasks->{$label};
            }
            default {
                die "Unknown command $command in logs";
            }
        }
    }
    return $tasks, $running;
}

# log the string to the log file
sub note {
    my $file = config->{LOG_DIRECTORY} . config->{LOG_FILE};
    open my $log, ">>", $file or die "Failed to open $file: $!";
    say $log scalar localtime . " " . join(" ", @_);    
}

# returns pretty format of time
sub pretty_time {
    my $time = new Time::Seconds shift @_;
    return $time->pretty;
}

=head2 man

Get the full man page.

  task man

=cut
sub man {
    pod2usage( -verbose => 2 );
}

=head2 help

Get help for one of the commands.

  task help [command]

=cut
sub help {
    my ($command) = @_;
    pod2usage( -verbose => 99, -sections => "COMMANDS/" . ($command ~~ COMMANDS ? $command : "OVERVIEW") );
}

=head2 start

Start the timer for a new or existing task.

  task start [task name]

=cut
sub start {
    my ($label) = @_ ? join " ", @_ : config->{DEFAULT_TASK};
    say "Starting $label";
    note "start", $label;
}

=head2 sub

Start the timer for a sub task.

  task sub [sub task name]

=cut
sub sub {
    my ($label) = @_ ? join " ", @_ : config->{DEFAULT_TASK};
    my ($tasks, $running) = tasks();
    die "Can't create a subtask when there is no task running" unless @$running;
    note "sub", $label;
    say "Started subtask $label";
}

=head2 stop

Stop the timer for the current task or subtask.

  task stop

=cut
sub stop {
    my ($tasks, $running) = tasks();
    die "No tasks running to stop" unless @$running;
    note "stop";
    say "Stopped" . (@$running > 1 ? " subtask " : " ") . $running->[-1]{label};
}

=head2 reset

Reset the timer for a task (and removes all subtasks).

  task reset label

=cut
sub reset {
    my ($label) = @_ or die "No task specified to reset";
    my ($tasks, $running) = tasks();
    die "No task called $label" unless $tasks->{label};
    note "reset $label";
    say "Reset $label";
}

=head2 list

List all the tasks.

  task list

=cut
sub list {
    my ($tasks, $running) = tasks();

    my $level;
    $level = sub {
        my ($tasks, $prefix) = @_;
        for my $label (sort keys %$tasks) {
            say "$prefix$label\t" . pretty_time $tasks->{$label}{time};
            &$level($tasks->{$label}{subtasks}, "$prefix\\$label");
        }
    };

    &$level($tasks, "");
}

=head2 flush

Archive the log so we can start a new one.

=cut
sub flush {
    my $file    = config->{LOG_DIRECTORY} . config->{LOG_FILE};
    my $archive = config->{LOG_DIRECTORY} . strftime "%Y-%m-%d_%H:%M:%S", localtime;
    die "No log to flush\n" unless -e $file;
    `mv $file $archive`;
    `gzip $archive`;
    say "Flushed log";
}

=head2 time

=cut
sub time {
    my ($label) = @_;
}

=head1 DESCRIPTION

This program times and logs tasks using a serries of log files stored in the log directory. 

=head1 CONFIGURATION

Configuration is taken from environment variables, ~/.task-timer, /etc/task-timer, in that order. The following variables can be used:

=head2 LOG_DIRECTORY

The directory to store logs in. The default is C<log/> relative to where the script is.

=head2 LOG_FILE

The file name to use for the log file. The default is C<current>.

=head2 SHORT

Can be set to change the output to be more suitable for use with scripts.

=head1 AUTHOR

Erik J. Sturcke

=cut
